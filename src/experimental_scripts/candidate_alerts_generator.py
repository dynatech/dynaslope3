"""
Candidate Alerts Generator (Py3) version 0.2
======
For use of Dynaslope Early Warning System
The main focus of Candidate Alerts Generator is to suggest
Alerts to be released to a release time especially when
it is due.
It works by checking the current status of a site from the DB
and comparing is to generated_alerts.json
1. Check if new_event, raising, lowering, rerelease
2. Fixes internal alert string
3. Extended Release
4. Routine Release

May 2019
"""

import json
import os
import requests
from datetime import datetime, timedelta, time
from run import APP
from connection import DB
from config import APP_CONFIG

from src.models.monitoring import (
    MonitoringEvents as me, MonitoringEventAlerts as mea,
    OperationalTriggerSymbols as ots, InternalAlertSymbols as ias)
from src.utils.sites import get_sites_data
from src.utils.extra import var_checker, get_routine_sites


##########################
# Utility functions here #
##########################

def generate_ias_x_ots_map():
    """

    """
    cross_map = {}
    trigger_symbols_list = ots.query.all()

    for item in trigger_symbols_list:
        cross_map[item.alert_symbol] = {
            "alert_level": item.alert_level,
            "internal_symbol": item.internal_alert_symbol.alert_symbol,
            "internal_alert_id": item.internal_alert_symbol.internal_sym_id
        }

    return cross_map


def get_generated_alerts_list_from_file(filepath, filename):
    """
    Reads the file generated by PublicAlertGenerator
    Returns a list
    """
    generated_alerts_list = []
    full_filepath = filepath + filename
    print(f"Getting data from {full_filepath}")
    print()

    with open(full_filepath) as json_file:
        gen_alert_data = json.load(json_file)

    return gen_alert_data


###################
# Data processors #
###################


def check_if_extended(validity, data_ts, data_time, is_extended_entry):
    is_extended_entry = validity < data_ts and data_ts < (
        validity + timedelta(days=3))
    is_extended_release = datetime.strptime(
        "11:00:00", "%H:%M:%S") < \
        data_time < \
        datetime.strptime("13:00:00", "%H:%M:%S")
    return is_extended_entry, is_extended_release


def format_alerts_for_ewi_insert(alert_entry, general_status):
    """
    Release time will come from user entry form to be added
    to release_details
    Publisher details will come from user entry form
    """
    site_id = alert_entry["site_id"]
    site_code = alert_entry["site_code"]
    alert_level = alert_entry["alert_level"]
    internal_alert = alert_entry["internal_alert"]
    data_ts = alert_entry["ts"]

    # On_set, re-release, raising
    if general_status in ["valid", "partially_invalid", "invalid"]:
        entry_type = 2  # Event Entry type

        # Completely invalid alert will not be processed by insert_ewi
        if general_status == "invalid":
            entry_type = -1

        # Get the internal alerts string only
        trigger_list = internal_alert.split("-")[1]

        formatted_alerts_for_ewi = {
            "general_status": general_status,
            "site_id": site_id,
            "site_code": site_code,
            "routine_sites_ids": [],
            "entry_type": entry_type,  # 2
            "alert_level": alert_level,
            "release_details": {
                "data_ts": data_ts,
                "trigger_list": trigger_list
            }
        }

        triggers = alert_entry["triggers"]
        trigger_list_arr = []
        for trigger in triggers:
            trig_dict = {
                "internal_sym_id": trigger["internal_sym_id"],
                "consolidated_tech_info": trigger["tech_info"],
                "invalid": trigger["invalid"],
                "trigger_alert_level": trigger["alert"]
            }
            trigger_list_arr.append(trig_dict)

        formatted_alerts_for_ewi["trigger_list_arr"] = trigger_list_arr

    # Routine
    elif general_status == "lowering":
        print("do that")
        entry_type = 2  # Routine entry type

        formatted_alerts_for_ewi = {
            "general_status": general_status,
            "site_id": site_id,
            "site_code": site_code,
            "routine_sites_ids": [],
            "entry_type": entry_type,  # 1
            "alert_level": alert_level,
            "release_details": {
                "data_ts": data_ts,
                "trigger_list": "",
                "release_time": ""
            },
            "publisher_details": {},
            "trigger_list_arr": []
        }
    elif general_status == "extended":
        print("do that")
        entry_type = 2  # Routine entry type

        formatted_alerts_for_ewi = {
            "general_status": general_status,
            "site_id": site_id,
            "site_code": site_code,
            "routine_sites_ids": [],
            "entry_type": entry_type,  # 1
            "alert_level": alert_level,
            "release_details": {
                "data_ts": data_ts,
                "trigger_list": "",
                "release_time": ""
            },
            "publisher_details": {},
            "trigger_list_arr": []
        }
    elif general_status == "routine":
        entry_type = 1  # Routine entry type

        formatted_alerts_for_ewi = {
            "general_status": general_status,
            "site_id": site_id,
            "site_code": site_code,
            "routine_sites_ids": [],
            "entry_type": entry_type,  # 1
            "alert_level": alert_level,
            "release_details": {
                "data_ts": data_ts,
                "trigger_list": "",
                "release_time": ""
            }
        }

    return formatted_alerts_for_ewi


def fix_internal_alerts(alert_entry):
    """
    Changes the internal alert string of each alert entry.
    """
    triggers = alert_entry["triggers"]
    internal_alert = alert_entry["internal_alert"]
    valid_alert_levels = []
    invalid_triggers = []

    for trigger in triggers:
        alert_symbol = trigger["alert"]
        trigger["internal_sym_id"] = IAS_X_OTS_MAP[alert_symbol]["internal_alert_id"]

        try:
            if trigger["invalid"]:
                invalid_ias = IAS_X_OTS_MAP[alert_symbol]["internal_symbol"]
                invalid_triggers.append(invalid_ias)
                internal_alert = internal_alert.replace(invalid_ias, "")
        except KeyError:  # If valid, trigger should have no "invalid" key.
            valid_a_l = IAS_X_OTS_MAP[alert_symbol]["alert_level"]
            valid_alert_levels.append(valid_a_l)

    if valid_alert_levels:
        # Get the maximum valid alert level
        highest_valid_public_alert = max(valid_alert_levels)
        # Convert the string into a list so we can manipulate characters via index
        listed_ia = list(internal_alert)
        # Change the 2nd char of internal_alert e.g. A'0'. Replace it with highest valid
        listed_ia[1] = str(highest_valid_public_alert)
        # Convert back to String. Note: String is immutable when accessed using indexes E.g. [1]
        internal_alert = "".join(listed_ia)

        general_status = "valid"
        if invalid_triggers:  # If there are invalid triggers, yet there are valid triggers.
            general_status = "partially_invalid"
    else:
        general_status = "invalid"

    return internal_alert, general_status


def process_generated_alerts(current_site_status, generated_alerts_list, query_end_ts):
    """
    Segregate entries into Raising, Lowering, Routine, Extended.
    """
    no_alerts_list = []
    candidate_alerts_list = []
    routine_sites_list = get_routine_sites(query_end_ts)

    for alert_entry in generated_alerts_list:
        # Get site_code to check current alert level of site
        site_code = alert_entry["site_code"]
        # Save the current alert level
        current_alert_level = current_site_status[site_code]

        # Get incoming alert level
        new_alert_level = int(alert_entry["public_alert"][1])
        # Save the alert level to alert entry for use on other parts of code
        alert_entry["alert_level"] = new_alert_level

        data_ts = datetime.strptime(alert_entry["ts"], "%Y-%m-%d %H:%M:%S")
        data_time = data_ts.time()  # For use in extended release validation

        if new_alert_level > 0:  # Process onset, raising, re-release with or without triggers
            # Step 1: Fix internal alert based on triggers
            fixed_list, general_status = fix_internal_alerts(alert_entry)

            # Step 2: Replace internal alert
            alert_entry["internal_alert"] = fixed_list

            # Format data needed by insert_ewi
            formatted_alert_entry = format_alerts_for_ewi_insert(
                alert_entry, general_status)

            candidate_alerts_list.append(formatted_alert_entry)
        else:  # Process lowering, routine, re-release (extended)
            # Checking of what to do
            is_lowering = new_alert_level < current_alert_level
            is_extended_entry = bool(
                alert_entry["validity"]) and new_alert_level == current_alert_level
            is_routine = new_alert_level == current_alert_level

            if is_lowering:
                print("LOWERING!")
                general_status = "lowering"
                formatted_lowering_alerts = format_alerts_for_ewi_insert(
                    alert_entry, general_status)
                candidate_alerts_list.append(formatted_lowering_alerts)
            elif is_extended_entry:
                # If incoming alert is zero but it still has
                # validity attribute, it is extended release
                validity = datetime.strptime(
                    alert_entry["validity"], "%Y-%m-%d %H:%M:%S")

                is_extended_entry, is_extended_release = check_if_extended(
                    validity, data_ts, data_time, is_extended_entry)

                if is_extended_entry and is_extended_release:
                    general_status = "extended"
                    formatted_extended_alert = \
                        format_alerts_for_ewi_insert(
                            alert_entry, general_status)
                    candidate_alerts_list.append(formatted_extended_alert)
            elif is_routine and not alert_entry["validity"]:
                general_status = "routine"

                if site_code in routine_sites_list:
                    formatted_routine_alerts = \
                        format_alerts_for_ewi_insert(
                            alert_entry, general_status)

                    candidate_alerts_list.append(formatted_routine_alerts)

            elif current_alert_level == -1:
                error = f"{query_end_ts} | DISCREPANCY IN DATA! IN SITE: {site_code.upper()}\r\n" 
                print(error)
                directory = APP_CONFIG["generated_alerts_path"]
                if not os.path.exists(directory):
                    os.makedirs(directory)

                with open(directory + "alert_gen_logs.txt", "a") as file_path:
                    file_path.write(error)

            no_alerts_list.append(alert_entry)

    return candidate_alerts_list, no_alerts_list


def get_current_alert_statuses_dict(query_end_ts):
    """
    Get current statuses for each site

    Returns a dictionary of sites with corresponding alert symbol
    E.g. {"agb": "A0", "bak": "A0", ...}

    Note: The following code might need some refactoring to improve performance
    """
    current_alert_status_dict = {}
    active_sites = get_sites_data()

    for site in active_sites:
        try:
            current_event = site.monitoring_events.order_by(DB.desc(me.event_start))\
                .filter(me.event_start < query_end_ts).first()
            current_event_alert = current_event.event_alerts.order_by(
                DB.desc(mea.ts_start)).filter(mea.ts_start < query_end_ts).first()
            current_alert_level = \
                current_event_alert.public_alert_symbol.alert_level  # This is what we need
        except AttributeError as err:
            print(err)
            print(f"MISSING @ {site.site_code}")
            current_alert_level = -1
        except Exception as err:
            print(err)
            raise

        site_code = site.site_code
        alert_level = current_alert_level

        current_alert_status_dict[f"{site_code}"] = alert_level

    return current_alert_status_dict


IAS_X_OTS_MAP = generate_ias_x_ots_map()


def main(ts=None, is_test=None):
    """
    Just a comment
    """
    start_run_ts = datetime.now()
    query_end_ts = ts if ts else datetime.now()
    query_end_ts = datetime.strptime(query_end_ts,  "%Y-%m-%d %H:%M:%S")
    is_test_string = "We are in a test run!" if is_test else "Running with DB!"
    print(
        f"Started at {start_run_ts}. {is_test_string}. QUERY END TS is {query_end_ts}.")

    ####################
    # START OF PROCESS #
    ####################
    filepath = "/var/www/dynaslope3/outputs/"
    filename = "generated_alerts.json"
    generated_alerts_list = get_generated_alerts_list_from_file(
        filepath, filename)

    current_site_status = get_current_alert_statuses_dict(query_end_ts)

    # Check triggers if there are invalids and fix the internal alert string as needed
    # Extended, Routine, Lowering

    candidate_alerts_list, no_alerts_list = \
        process_generated_alerts(
            current_site_status, generated_alerts_list, query_end_ts)

    # Convert data to JSON
    json_data = json.dumps(candidate_alerts_list)

    # Write to specified filepath and filename
    directory = APP_CONFIG["generated_alerts_path"]
    if not os.path.exists(directory):
        os.makedirs(directory)

    with open(directory + "candidate_alerts.json", "w") as file_path:
        file_path.write(json_data)

    end_run_ts = datetime.now()
    run_time = end_run_ts - start_run_ts
    print(f"RUNTIME: {run_time}. Thank you for using this program.")


if __name__ == "__main__":
    main("2018-11-30 15:56:00", True)
